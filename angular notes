/*
1. Build an Application with Angular 2 and Firebase - Application Demo and Course Objectives
intro

2. Installing Node and the Angular 2 and Firebase Demo Application
- need node 6 or higher
to install go to nodejs.org and use downloader.
- to see the final version go to github.com/angular-university/courses go into 'getting started' then 'final-project'. download repo.
  * run 'npm install'
  * install angular-cli globally: 'npm install -g angular-cli'
  * 'ng serve'
  * url: localhost:4200

3. Angular 2 Final Application Scaffolding using the Angular CLI
setup:
node -v = check version. want > 6.
install angular cli:
sudo npm install -g angular-cli
ng new final-project
cd final-project
ng serve

4. Installing the Starter Kit
https://github.com/angular-university/angular-firebase-app-starter

5. Firebase Real-Time Database Hello World - First Query - Debug Websockets !
setup firebase with firebase sdk
sign into firebase.google.com (for tutorial, used my gmail account diane.douglas1)
create new project from console 'final-project-recording'
click on it and from welcome -> 'database', go to security rules and start by setting read/write to "true". hit 'publish'.
click 'add firebase to web app' from console
copy whole thing and paste to index.html under <app-root>
select project -> 'database'.
name root node 'Hello World Firebase' in browser editor.

// then in index.html under the 'initializeApp'
```
var root = firebase.database().ref();
```
// subscribe to value and pass in callback, called when value is available in // browser. pass in callback a variable 'snap' and log it.
```
root.on('value', function(snap) {
  console.log(snap.val());
})
```
function is called when the value is available in the browser and whenever it changes in real time. uses web sockets. view data in dev tools under Network > WS

A reference, and a snapshot.

6. Firebase Fundamentals - References, Snapshots and Keys

a reference is a reference to any node in the firebase, not just root.
we can point to 'messages' or 'users' by specifying it in the .ref call.

var root = firebase.database().ref('messages');
or
var root = firebase.database().ref('messages/2');

root.on('value', function(snap) {
  console.log(snap.key, snap.val());
})
*** arbitrary structure like json
*** point to any node with a reference
*** and query and receive back a snapshot containing key and value.
array v object? firebase array support more later.

7. Use Firebase SDK with Typescript - Preparing to Run a Firebase Database Population Script

install firebase via npm to fill database using a script.
take out the script tag loading the firbase sdk.
npm install firebase --save
then require it in app.component.ts:

import { Component } from '@angular/core';
import { initializeApp, database } from 'firebase';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'app works!';
  //////added
  constructor() {
    // Initialize Firebase
    var config = {
      apiKey: "AIzaSyAwuKl7qjXwEFV4e_XdCLY8goNChIMgc1w",
      authDomain: "tutorial-b967f.firebaseapp.com",
      databaseURL: "https://tutorial-b967f.firebaseio.com",
      storageBucket: "tutorial-b967f.appspot.com",
      messagingSenderId: "979501840072"
    };
    initializeApp(config);

    var root = database().ref('users');
    root.on('value', function(snap){
      var users = snap.val();
      var key = snap.key;
      // console.log(users[0].name);
      users.forEach(function(user){
        console.log(user.name);
      })
    })
  }
  ////////
}


8. firebase push key is the long string of crap that forms an id.
and also 9. Firebase Data Modeling 101 - How To Model Data In Firebase ?
node = a table in sql

in order to run 'npm run populate-db' we need ts-node installed.
npm install ts-node -D

In the script, we are looping through an array of course objects.
Each course object has an array stored at the key of "lessons" and the array holds lesson objects.
First we create an entry in the courses table, then we create an entry in the lessons table, get its key and store it in an array.
Finally the array of lesson keys gets stored in the third table under the course id. Each lesson key is stored with a value of true. this is an association node.
keep data flat.

10. Firebase Key Generation - How to use the Firebase Push Keys, Should We Use Them and Why ?

generated by firebase for us, corresponding to the timestamp. sort by time.
they can be syncronously generated in the client without having to contact the database for that. client generates it and pushes the data to the server. no need to verify uniqueness.

11. Firebase Arrays - Does Firebase Support Arrays ?
Not really. arrays are dangerous because you can't rely on things being in the same order.
if you do use numeric keys, firebase sdk returns a snapshot of an array. but you should probably avoid it and embrace 'lists' in firebase. push to a list to generate a key.

12: AngularFire 2 Hello World - How To Write your First Query using AngularFire 2

How to query lists in firebase
instead of firebase sdk we are going to use AngularFire library instead.
npm install angularfire2 --save

Then add module to imports of app.module.ts
imports: [
  AngularFireModule.initializeApp(firebaseConfig)
]

13: AngularFire 2 Object Observables - How to Read Objects from a Firebase
There are two primitives FirebaseListObservable and FirebaseObjectObservable

object observable lets us get a single object and subscribe to it, list observable is for groups of objects.

const course$ : FirebaseObjectObservable<any> = af.database.object('courses/-K_fUAmBdZLQRnQWPmQM')
course$.subscribe(
  val => console.log(val)
)

14: How to Write Data to the Database using AngularFire 2 ? Adding Elements to a List

listPush.
get reference to courses and call listPush on it. It will add an element to the list!
just get a reference to a list node, call 'push' method and pass an object in to add it to the database.

reference:

this.courses$ = af.database.list('courses');

trigger this from a button to save:

this.courses$.push({name: 'Wizardry'})
  .then(
    () => console.log('List Push Done'),
    () => console.log('There was an error.')
  );
// one object at a time for push method.

15. How To Remove an Element from a List using AngularFire 2 ?

Delete with listRemove. pass it in an element of the list.
subscribe to the element you want to remove and store it in a property so that you can pass it into the firebase 'remove' method.
// make a property to hold the thing you want to delete:
  firstCourse: any;

// make a reference to the list of things that you are deleting from
this.courses$ = af.database.list('courses');

// get the first course object and subscribe to it, and store it in the 'firstCourse' property.
this.courses$.map(courses => courses[0])
  .subscribe(
    course => this.firstCourse = course
  );

// pass that property into the courses$ list reference remove method in a function called from a button.

listRemove() {
  this.courses$.remove(this.firstCourse);
}

16. How To Update an Element in a Firebase List using AngularFire 2 ?
Take an object and change the value of a property without changing the other ones.

Reuse the property you made with map/subscribe by passing it into the update method on the list that holds the object you are changing. Then the update method takes a second argument which is an object holding just the key/value pairs you want to change.

listUpdate() {
  this.courses$.update(this.firstCourse, {name: "advanced wizardry"});
}

17. How to Modify an Object in Firebase using AngularFire 2, what is the Difference Between Set and Update?

firebase Object observables have methods similar to list observables. We call them on the things we make with subscribe.
.remove() will delete the object you have subscribed to.
.update({key: value}) will edit the object you have subscribed to, preserving any key/value pairs that you are not changing.
.set({key: value}) will remove any properties you don't include in the object you pass in.

18. Starting the Application From the Beginning - Build the Home Screen
display lessons on the screen

create home component
ng generate component home
<app-home></app-home>

then in app/home you will find your component.ts and .html files.
inject service in each of your components

19. Building our First Firebase Service - The Lessons Service
ng generate service shared/model/lessons
note: path to service has to exist already. had to create model folder.

add it to the providers array in app.module.ts

import {LessonsService} from "./shared/model/lessons.service";
providers: [LessonsService],

*LessonsService is what we are exporting from the service file.

then inject in the component constructor

then call it in ngOnInit.
*****
constructor(private LessonsService: LessonsService) { }

ngOnInit() {
  this.lessonsService.findAllLessons();
}
*****

make a method called 'findAllLessons' - like our getAll
returns an observable with a list of observables.

Now we want a lesson type
in the model, add the lesson class.
shared/model/lesson.ts

export class Lesson {
  constructor(
    public $key: string,
    description: string,
    duration: string,
    url: string,
    tags: string,
    videoUrl: string,
    longDescription: string,
    courseId: string
  )
}


Then in lessons service make method called 'findAllLessons', not type any anymore.
inject AngularFire in the service constructor.
also import the model, AngularFire, and Observable in the service.

findAllLessons(): Observable<Lesson> {
  return this.af.database.list('lessons');
}

Then, in ngOnInit in our component with the LessonsService imported, and we inject it in the constructor, then we're able to call its findAllLessons() method, which returns an observable, which we subscribe to in the component.

lessons: Lesson[];

ngOnInit() {
  this.lessonsService.findAllLessons()
    .subscribe(
      lessons => this.lessons = lessons
    )
}

for debugging add do method with map method from rxjs library in app.module
Then you can print out the result from your observable with:

this.lessonsService.findAllLessons()
  .do(console.log)
  .subscribe(
    lessons => this.lessons = lessons
  )

  then we can use this.lessons in our template.


Total Lessons: lessons?.length

*ngFor="let lesson of lessons"
{{lesson.description}}

19. Angular 2 Smart Components vs Presentation Components: What's the Difference and When to Use Each ?

Smart components are tied to the service, and inherently the app, presentation components just display whatever data you pass to them.

20. Pitfall of using typescript classes
Only properties are allowed in the model. What you get back from the findAllLessons method is a JSON object, or a list of JSON objects. Which itself is probably inside a JSON object. But whatever. The idea is that we can get our data back in the service like this:
*/

// inside our service
findAllLessons(): Observable<Lesson[]> {

  return this.af.database.list('lessons')
    .do(console.log)
    .map(lessonsAsJson => Lesson.fromJsonList(lessonsAsJson));

}

// In the Lesson model class lesson.ts
// Create two static functions. One of them translates a list of observables into an array of Lessons
// the other one translates a single observable object into a single Lesson object - which is actually useful.


class Lesson {
  constructor(){}

  static fromJsonList(arrayOfLessonObservables):Lesson[] {
    return arrayOfLessonObservables.map(inputJsonSingleLesson =>
      Lesson.fromJson(inputJsonSingleLesson));

  }

  static fromJson({
      $key,
      description,
      duration,
      url,
      tags,
      videoUrl,
      longDescription,
      courseId}):Lesson {
    return new Lesson($key, description, duration, url, tags, videoUrl, longDescription, courseId);
  }
}


//21. How to implement clientside search.

WE have a component inside of our home component that displays all lessons.
We are passing that array of lessons in as a regular input parameter.

in the home template:

<lessons-list [lessons]="lessonsProperty"></lessons-list>

Then we want to rename 'lessonsProperty' property in the home component to 'allLessons' and adds a new one called 'filtered'.
This will hold the lessons that match the search term.
We will also now pass in the 'filtered' property to the lessons-list component to only display those.

inside of ngOnInit we are querying the database by calling 'findAllLessons' in our service.
Then we subscribe to the return value.
And inside of subscribe we can set both 'allLessons' and 'filtered' equal to the array of lessons we get back fromthe db.

ngOnInit() {
  this.lessonsService.findAllLessons()
    .do(console.log)
    .subscribe(
      lessons => this.allLessons = this.filtered = lessons
    )
}

Then we need to make filtered property react to changes in the search bar and only hold the lessons that match.

Here's the search bar.

<input (keyUp)=search(typedInput.value) #typedInput>

Then define the search method.

'
search(userInput) {
  this.filtered = this.allLessons.filter( currentLesson => currentLesson.description.includes(userInput));
}

22. Setting Up the Router Configuration of our Application

Router module

router.config.ts in /src/app


import {Route} from '@angular/router';
import {HomeComponent} from './home/home.component';
// import all components you are routing to

export const routerConfig : Route[] = [
  {
    path: 'home',
    component: HomeComponent
  },
  {
    path: '',
    redirectTo: 'home',
    pathMatch: 'full'
  },
  {
    path: '**',
    redirectTo: 'home'
  }
];
export an array of Route objects tying a path to a component
_____

then in the app component we need to put the <router-outlet> directive in the template.
_____
then add RouterModule to imports array in app.module.ts:

import {RouterModule} from '@angular/router';
import {routerConfig} from './router.config';

imports: [
  BrowserModule,
  AngularFireModule.initializeApp(firebaseConfig),
  FormsModule,
  HttpModule,
  RouterModule.forRoot(routerConfig)
],

23. Building a Navigation Menu Using The Angular 2 Router

ng g component top-menu

this component holds links to other components
you can use the generated .css file to affect only the current component

also creates 'courses' component
ng g component courses

add route to new component in router  with import component statement.

then make router link:
<a routerLinkActive="menu-active" routerLink="path" [routerLinkActiveOptions]="{exact:true}">TEXT</a>
[routerLinkActiveOptions]="{exact:true}" is used when your link is a blank string

24.Setting Up the Master Screen of the Master Detail Pattern
_______
generate courses service:
ng g service shared/model/courses
add service to the providers array in app.module.ts
________
setting up courses component:
then in the courses.component.ts
inject service in the constructor, made the courses$ property to hold the observable array of courses.
Then we added a call to the service's 'findAllCourses' method which we are about to define.

import { Component, OnInit } from '@angular/core';
import { CoursesService } from '../shared/model/courses.service';
import { Observable } from 'rxjs/Rx';
import { Course } from '../shared/model/course.ts';

@Component({
  selector: 'app-courses',
  templateUrl: './courses.component.html',
  styleUrls: ['./courses.component.css']
})
export class CoursesComponent implements OnInit {
  courses$: Observable<Course[]>;

  constructor(private coursesService: CoursesService) { }

  ngOnInit() {
    this.courses$ = this.coursesService.findAllCourses();
  }

}
__________
then make course model shared/model/course.ts
structure looks like this:
export class Course {
  constructor(properties)
  static fromJson
  static fromJsonList
}

actual file:
export class Course {
  constructor(
    public $key: string,
    public url: string,
    public description: string,
    public iconUrl: string,
    public courseListIcon: string,
    public longDescription: string) {

  }


  static fromJsonList(json) : Course[] {
    return json.map(Course.fromJson);
  }

  static fromJson({$key, url, description, iconUrl, courseListIcon, longDescription}):Course {
    return new Course($key, url, description, iconUrl, courseListIcon, longDescription);
  }

}

__________

Then, in the courses.component.html
we can loop through courses$ observable by using async pipe

<p *ngFor="let course of (courses$ | async)">
  {{course.description}}
</p>
_________

then in the courses service we have to define the findAllCourses method and inside of it, we call the static fromJsonList method in our course model.


import { Injectable } from '@angular/core';
import {AngularFire} from 'angularfire2';
import {Observable} from 'rxjs/Rx';
import {Course} from './course';

@Injectable()
export class CoursesService {

  constructor(private af: AngularFire) { }

  findAllCourses(): Observable<Course[]> {
    return this.af.database.list('courses').map(Course.fromJsonList);
  }
}
25. Configuring the Angular 2 Router for Master To Detail Navigation
__________

create course detail component
ng g component course-detail

then add route to router.config.ts
instead of this:

{
  path: 'courses',
  component: CoursesComponent
},

we want this:

import {CoursesComponent} from './courses/courses.component';
import {CourseDetailComponent} from './course-detail/courses-detail.component';

{
  path: 'courses',
  children: [
    {
      path: ':id',
      component: CourseDetailComponent
    },
    {
      path: '',
      component: CoursesComponent
    }
  ]
},
*** remember to restart server after adding a new file with ng generate.

_______

Then in the courses.component.html file we want to create links to navigate to each course detail

<button [routerLink]="course.url">View</button>
don't forget square brackets in this case around routerLink.

This navigates to the relative url of the current page which would be /courses.
this would go to courses/whatever-is-in-that-url-property

26. Setting Up the Detail Screen of a Master Detail Setup
what links lessons to courses is the lessonsPerCourse node.
  courses
  lessons
  lessonsPerCourse
    courseId
      lessonId1 = true
      lessonId2 = true
      lessonId3 = true
      lessonId4 = true
set to true because we only need the key.
_______
in courses detail component:
create property to hold the lessons in current course:
lessons$: Observable<Lesson[]>;

Then inject the courses service in the constructor
also inject the the 'activated route' Injectable provided by the router.
The activated route Injectable lets us get parameters out of the url.

and in ngOnInit call the service's 'findLessonsForCourse' method we're about to make.
Pass it in the id of the course we're interested in, or the URL.

27. How To Make a Join in Firebase Using AngularFire 2 ? Reading a Course based on its url

query courses node based on the url property. find match, retrieve course.
Then we're going to use the course $key property in the lessonsPerCourse.
Find course and retrieve its list of lessons.
Then with each lesson key we're going to query the lessons node and get the lesson properties.

in courses service:
inject AngularFireDatabase directly in courses service.
constructor(private db: AngularFireDatabase) { }
then add two methods. One is findCourseByUrl using query.

findCourseByUrl(courseUrl: string): Observable<Course> {
  return this.db.list('courses', {
    query: {
      orderByChild: 'url',
      equalTo: courseUrl
      // courseUrl is passed in here from our 'id' parameter in course-detail.
    }
  }).map(results => results[0]);
}

Then we add the second method to find the lessons for that course:

findLessonsForCourse(courseUrl: string): Observable<Lesson[]>{

  // get course observable we have navigated to by url.
  const course$ = this.findCourseByUrl(courseUrl);

  // go to the lessonsPerCourse table(node)
  // inside of there, find the course table by $key output lessons.
  // get back gross firebase object observable array.
  const lessonsPerCourse$ = course$
    .switchMap(course => this.db.list('lessonsPerCourse/' + course.$key))
    .do(console.log);

    // talking to the reference we got back from lessonsPerCourse above
    // for each firebaseObjectObservable in that array we call db.object to get back the observable for the lesson from the lessons table
    // this is at the address lessons/lessonkey
    // THEN we call flatmap on that and somehow that gives us an array of useable lesson objects.
  return lessonsPerCourse$
    .map(lessonsPerCourseParameter => lessonsPerCourseParameter.map(lesson => this.db.object('lessons/' + lesson.$key)) )
    .flatMap(fbojs => Observable.combineLatest(fbojs) )
    .do(console.log);
}


________

28.  Displaying the Lessons Per Course in the Course Detail Page

in course-detail.ts:
we are now talking to the service to call both findCourseByUrl to display the name of the course and findLessonsForCourse to display the lessons.
we store the return value from each of those in an observable property which we can display in the template.

lessons$: Observable<Lesson[]>;
course$ : Observable<Course>;

constructor(private route: ActivatedRoute, private coursesService:CoursesService) { }

ngOnInit() {
  // need to pass in the course id from URL
  const courseUrl = this.route.snapshot.params['id'];
  this.course$ = this.coursesService.findCourseByUrl(courseUrl);
  this.lessons$ = this.coursesService.findLessonsForCourse(courseUrl);
}
________
In the template we just have to remember to use the async pipe.
You can pass these observables into child components if you like or loop through them.
Just have to remember that for displaying specific properties you have to use the elvis ? operator.


// one property of an observable
<h2>{{ (course$ | async)?.description }}</h2>

// a list of observables being passed into a child component
<lessons-list [lessons]="lessons$ | async"></lessons-list>
// then in the child component lessons is treated normally because async already used.
<li *ngFor="let lesson of lessons">{{lesson.description}}</li>

_______
29.How To Do Pagination in Firebase ? Loading the First Page of a Paginated Table
query parameters:
you could 'startAt' a certain lesson, orderByValue, and 'limitToFirst' 10 results.
or reverse: 'endAt' element to end at the query and 'limitTo' last for only the last 10 results.

first page of 3 elements
emit startAt property limiToFirst 3.
make new method to call from course-detail in service:

loadFirstLessonsPage(courseUrl: string, pageSize): Observable<Lesson[]> {

}

call from course-detail:
// get 3 results.
this.lessons$ = this.coursesService.loadFirstLessonsPage(courseUrl, 3);
_______
SHORT BREAK FROM VIDEOS HERE BECAUSE NOTHING WOULD COMPILE ON MY COMPUTER.
For reference for later here's what I did.

I got this error that was preventing shit from running.
https://stackoverflow.com/questions/41285889/ctorparameters-map-is-not-a-function-in-angular2-mdl

tried to fix it as described above by updating the angular cli to "angular-cli": "1.0.0-beta.24", as described but didn't work/didn't fix it all the way - gave me different errors. so tried this: https://github.com/angular/angular-cli/issues/2835
  1.  delete node_modules
  2.  do a fresh npm i angular-cli@1.0.0-beta.18 -g
  3.  do again ng init
  4.  Y --> override package.json

this seems to have also given me that angular cli beta.24 version plus other stuff. 

then, I got rid of the 'can't find angularfire' etc errors created because I overwrote package.json by installing angularfire2 and firebase from install intructions on angularfire:
npm install firebase angularfire2 --save

then new errors. https://github.com/angular/angular-cli/issues/3665
change versions for all angular packages in package.json to one version 2.3.1
Lock your @angular packages to "2.3.1"
delete node modules, run npm install again.


got this error: https://github.com/angular/angular-cli/issues/3799
tried to change compiler-cli to 2.4.1 as per instructions but didn't do anything and app was running succesfully with this error anyway so i committed.

FINALLY getting rid of last error: 
also from here: https://github.com/angular/angular-cli/issues/3799
ran "ng init", say Y for overwriting everything except app.component. 
I assume this is different from the "npm i" I did earlier. 

then delete node modules
npm install
npm install firebase angularfire2 --save
ng serve

This worked without errors. Somewhere in there I had to change the statement where we import our model to not use .ts at the end because apparently that's important now:

import { Course } from '../shared/model/course';

instead of:

import { Course } from '../shared/model/course.ts';

finally made sure i could still build:
reclone 
git checkout tutorial-dev
npm install
typings install

ONWARD>>>>>>>

______________________

30. PART 1 of Firebase Pagination Continued - Loading the Next Page

Here I fixed the rest of the first part of pagination. At this point we are seeing the first 3 results of lessons in a given course. Here are the ingredients:
________________________________THE HTML
In course-detail.html

<lessons-list [lessons]="currentLessons$ | async"></lessons-list>

Here we are passing in the currentLessons$ property to the lessons-list component using the async pipe. lessons-list is a normal component that doesn't have anything to do with observables or the database.


  @Input()
  lessons: Lesson[];

We also have access to the current course's properties in course-detail:

<h2>{{ (course$ | async)?.description }}</h2>
________________________________NEXT: The typescript talking to the service

Inside of course-detail in ngOnInit we need to call the service to fill the currentLessons$ property.


  currentLessons$: Observable<Lesson[]>; //displayed in html passed into lessons-list
  course$ : Observable<Course>; 

  constructor(private route: ActivatedRoute, private coursesService:CoursesService) { }

  ngOnInit() {
    //get the course's url property from id parameter in this url. this is confusingly stored in 'id'
    const courseUrl = this.route.snapshot.params['id']; 
    //first find the course to display its description.
    this.course$ = this.coursesService.findCourseByUrl(courseUrl); // pass in 
    //load the first 3 lessons for this course. 
    this.currentLessons$ = this.coursesService.loadFirstLessonsPage(courseUrl, 3);

  }

_________________________________NEXT IN THE SERVICE

loadFirstLessonsPage(courseUrl: string, pageSize: number): Observable<Lesson[]> {
  // receive course url we want and the number of lessons we want from that course.
  // call findLessonKeysPerCourseUrl by passing in the courseUrl and the query object.
  const firstPageLessonKeys$ = this.findLessonKeysPerCourseUrl(courseUrl,
    {
      query: {
        orderByKey: true,
        limitToFirst: pageSize
      }
    })
  .do(console.log); //print
  //finally, translate the returned lesson keys from above into lesson object observables.
  return this.findLessonsForLessonKeys(firstPageLessonKeys$);
}

The two utility functions used by the one above are:

findLessonKeysPerCourseUrl(courseUrl: string, query: FirebaseListFactoryOpts = {}): Observable<string[]> {
  // return the lesson keys that belong to an individual course including a query object optionally
  // find the course and then do a list call to the join table with the query object spit out an array of keys.
  return this.findCourseByUrl(courseUrl)
    .switchMap(course => this.db.list('lessonsPerCourse/' + course.$key, query))
    .map(lspc => lspc.map(lpc => lpc.$key));
}


Then this function uses the output of the previous function to translate into lesson objects from array of keys (observable strings)
  findLessonsForLessonKeys(lessonKeys$: Observable<string[]>):Observable<Lesson[]> {
    return lessonKeys$
      .map(lspc => lspc.map(lessonKey => this.db.object('lessons/' + lessonKey)))
      .flatMap(fbojs => Observable.combineLatest(fbojs))
  }

At this point we should be able to see the first 3 lessons of each course.
_______________
Then we need to get the next page...

in course-detail:

 // subscribe to observable to store it in property as not an observable so you  don't need to use async pipe to display.
 lessons: Lesson[]; //we use this to get the last lesson's key from this page to use for next method -not observable

 lessonsObservable$: Observable<Lesson[]>; // this used to be called currentLessons$. Changed its name since it's not going to be used in the template anymore to show the current lessons. 
 course$ : Observable<Course>;
 courseUrl: string;
 constructor(private route: ActivatedRoute, private coursesService:CoursesService) { }

 ngOnInit() {
   // need to pass in the course id from URL
   this.courseUrl = this.route.snapshot.params['id'];
   this.course$ = this.coursesService.findCourseByUrl(this.courseUrl);
   this.lessonsObservable$ = this.coursesService.loadFirstLessonsPage(this.courseUrl, 3);
   this.lessonsObservable$.subscribe(lessons => this.lessons = lessons); // subscribe to observable to store it in property as regular fuckin array of objects !!!!!!
   console.log(this.lessons);
   // need access to the last element of the lessons array to get its key. 
   // so we subscribe to observable retrieve lessons and store them in the lessons variable as not an observable.
   // also need to store course url as property to use it in multiple methods.

 }


 next() {
   var lengthOfLessons = this.lessons.length;
   var keyOfLastLessonOnPage = this.lessons[lengthOfLessons - 1].$key;
   
   this.coursesService.loadNextPage(this.courseUrl, keyOfLastLessonOnPage, 3)
     .subscribe(lessons => this.lessons = lessons);
 }

 Now in the HTML we can change currentLessons$ observable with async to normal lessons property:

 <lessons-list [lessons]="lessons"></lessons-list>


 Then in service:

  loadNextPage(courseUrl:string, lessonKey:string, pageSize:number): Observable<Lesson[]> {
    // get lesson keys for this course but with query object for next 3 results
    const lessonKeys$ = this.findLessonKeysPerCourseUrl(courseUrl, 
    {
      query : {
        orderByKey: true,
        startAt: lessonKey, // start at current lessonkey
        limitToFirst: pageSize + 1 //get 4, leave out the current one.
      }
    }); //translate to lesson observable objects
    return this.findLessonsForLessonKeys(lessonKeys$)
      .map(lessons => lessons.slice(1, lessons.length)); //here is where we remove the current lesson 
  }

  Also, don't forget to hook up the button :)

  <button (click)="next()">Next Course</button>

  NOW YOU CAN SEE 3 RESULTS AT A TIME WOOOOOOO!!!!
  _____________________ 
  31.  Firebase Pagination Concluded - Loading the Previous Page
  PREVIOUS PAGE

  In service:

    loadPrevPage(courseUrl:string, lessonKey:string, pageSize:number): Observable<Lesson[]> {
    const lessonKeys$ = this.findLessonKeysPerCourseUrl(courseUrl, 
    {
      query : { //same as loadNextPage but we want the final 4 results, not first 4, limited to current page's first lesson. so change startAt to endAt and limitToFirst to limitToLast.
        orderByKey: true,
        endAt: lessonKey,
        limitToLast: pageSize + 1
      }
    });
    return this.findLessonsForLessonKeys(lessonKeys$)
      .map(lessons => lessons.slice(0, lessons.length - 1)); //then we use slice to keep the whole array but the last element.
  }

  In course-detail HTML hook up button to prev() method. we're still going to use the lessons property to hold our current 3 results.

  <button (click)="prev()">Previous Course</button>

  then implement:

    prev() {
    // get key of first lesson in array to pass in because this is what we will limit our results to. 
    // use 'endAt' this key and 'limitToLast' = 3 in query (in service) 
    // means start with this lesson key and count backwards to get 3 results. 
    // subscribe to output and store in same this.lessons property we've been using in template.
    this.coursesService.loadPrevPage(this.courseUrl, this.lessons[0].$key, 3)
      .subscribe(lessons => this.lessons = lessons);
  }

  ____________
32. Navigate From Course Detail to Lesson Detail

ng g component lesson-detail
restart server
configure router. At top level, incude id parametr to hold the lesson's url parameter. 

export const routerConfig : Route[] = [
  {
    path: 'home',
    component: HomeComponent
  },
  {
    path: 'courses',
    children: [
      {
        path: ':id',
        component: CourseDetailComponent
      },
      {
        path: '',
        component: CoursesComponent
      }
    ]
  },
  {
    path: 'lessons/:id',
    component: LessonDetailComponent
  },
  {
    path: '',
    redirectTo: 'home',
    pathMatch: 'full'
  },
  {
    path: '**',
    redirectTo: 'home'
  }
];

Next, we need to be able to click on a lesson to navigate to the new route. So, starting from the course-detail component, let's declare a custom event emitter on the lessons list component. It will emit on the 'lesson' output triggering a method in course-detail called navigateToLesson and pass in the lesson object we clicked on. 

<lessons-list [lessons]="lessons" (lesson)="navigateToLesson($event)"></lessons-list>

Then, navigateToLesson will do the navigating.


  navigateToLesson(lesson:Lesson) {
    this.router.navigate(['lessons', lesson.url]);
  }

It needs the Router object, so we import and inject it:

import { ActivatedRoute, Router } from '@angular/router';
constructor(private router: Router, private route: ActivatedRoute, private coursesService:CoursesService) { }

Now in lessons-list we need the click handler to trigger the event emitter when we click on a lesson and pass in that lesson. so in lessons-list.component.html:

<li *ngFor="let lesson of lessons" (click)="selectLessonDetail(lesson)">{{lesson.description}}</li>

Then, in its component ts half:

import EventEmitter and Output, then define the event emitter:

  @Output('lesson')
  lessonEmitter = new EventEmitter<Lesson>();

  selectLessonDetail(lesson:Lesson) {
    this.lessonEmitter.emit(lesson);
  }

Now when we click on a lesson, we go to lessons/its-url in our browser.

Again, just like courses, the lesson url has to be unique.

__________________________
33.  Building a Lesson Detail Component

First, we need the activated route injected and to get the id (lesson url) out of the browser url.

Also need to inject lessonsService in constructor

Then we're going to make and call a method on it called findLessonByUrl.
____
constructor(private route:ActivatedRoute, private lessonsService:LessonsService) { }

ngOnInit() {
  const lessonUrl = this.route.snapshot.params['id'];
  const lesson$ = this.lessonsService.findLessonByUrl(lessonUrl);
}
____
Then we call subscribe to assign the returned observable to a property to display in the template:

  currentLesson: Lesson;

  constructor(private route:ActivatedRoute, private lessonsService:LessonsService) { }

  ngOnInit() {
    const lessonUrl = this.route.snapshot.params['id'];
    const lesson$ = this.lessonsService.findLessonByUrl(lessonUrl);
    lesson$.subscribe(lesson => this.currentLesson = lesson);
  }

_____
in the service, we simply query by url:

findLessonByUrl(url:string):Observable<Lesson> {
  return this.af.database.list('lessons', {
    query: { //use orderByChild if you want to sort by a model property.
      orderByChild: 'url',
      equalTo: url
    }
  }).map(results => results[0]); // get the first one that matches.
}

_____
Finally, in the template we just have to remember to use the elvis operator, or I assume async if this were an array.

<p>
  Lesson Details:
  {{currentLesson?.description}}
</p>

_____

We'll want to add ".indexOn": "url" at /lessons to  security rules to get rid of a warning like we did with /courses.

________

34. Angular 2 Security - Adding an iframe to an Angular 2 Template 

Not very relevant to us. 
We can generate a pipe with: 
ng g pipe shared/security/safe-url
(remember to make the directory src/app/shared/security first)

then we load an iframe like this:

<iframe *ngIf="currentLesson?.videoUrl"
        width="260" height="150" frameborder="0" allowfullscreen
        [src]="currentLesson?.videoUrl | safeUrl">
</iframe>

If we tried to do this without the pipe, we would be trying to use an iframe with data fetched from our backend and this would cause an "unsafe value used in resource url" error because of cross site scripting attacks XSS. That data could be intercepted and we might not show the content we want to.

so we protect by implementing the pipe to mark that content safe:

import { DomSanitizer } from '@angular/platform-browser';

constructor(private sanitizer: DomSanitizer){}

  transform(url): any {
    return this.sanitizer.bypassSecurityTrustResourceUrl(url);
  }

  __________

  35-36. Navigating From Lesson To Lesson - Part 1 and 2
he says we need to install these packages but I didn't and they worked anyway.

npm install lodash --save
npm install @types/lodash --save

in the lesson-detail component we need a next/prev button methods.

<button (click)="previous()">Prev Lesson</button>
<button (click)="next()">Next Lesson</button>

Then, we create the two methods in lesson-detail:

next() {
  this.lessonsService.loadNextLesson(this.currentLesson.courseId, this.currentLesson.$key)
    .subscribe(
      lesson => this.router.navigate(['lessons', lesson.url])
    );
}

previous() {
  this.lessonsService.loadPreviousLesson(this.currentLesson.courseId, this.currentLesson.$key)
    .subscribe(
      lesson => this.router.navigate(['lessons', lesson.url])
    );
}

we are passing in the current lesson's course id and its $key. then lessons service returns an observable we subscribe to in order to use it with router's navigate method. go to lessons/lesson.url

make sure to import and inject the router:

import { ActivatedRoute, Router } from '@angular/router';
constructor(private router:Router, private route:ActivatedRoute, private lessonsService:LessonsService) { } 

But this doesn't work and gives no errors!

if loading stuff doesn't work and there are no errors, it is probably the router not taking you somewhere. remember you need to not use ngOnInit if you are navigating between the same componnt because ngOnInit is only called once. so can't use snapshot within. 

must refactor the ngOnInit:


ngOnInit() {
  // const lessonUrl = this.route.snapshot.params['id']; //for using this component more than once, prev/next lesson, 
  // snapshot doesn't work within ngOnInit - only called once when component loaded the first time.
  // const lesson$ = this.lessonsService.findLessonByUrl(lessonUrl);
  var lesson$ = this.route.params.switchMap(params => {
    const lessonUrl = params['id'];
    return this.lessonsService.findLessonByUrl(lessonUrl);
  });
  lesson$.subscribe(lesson => this.currentLesson = lesson);
}

This is giving me a 'supplied paramters don't match any signature of call target' error for this line:
const lessonUrl = params['id'];
but everything works so whatever. error is only in text editor.

__________
37.  The Create New Lesson Form

import reactive forms in app.module

import { ReactiveFormsModule } from '@angular/forms';
then include in the imports array. 

ng g component new-lesson

form and save button should be in separate component to be used for edit too

ng g component lesson-form

configure router:

button to go to new lesson form in course detail component so we can attach it to a course

instead of this:
{
  path: 'courses',
  children: [
    {
      path: ':id',
      component: CourseDetailComponent
    },
    {
      path: '',
      component: CoursesComponent
    }
  ]
},

  we want

import {NewLessonComponent} from './new-lesson/new-lesson.component';

{
  path: 'courses',
  children: [
    {
      path: ':id',
      children: [
        {
          path: '', //show same lessons per course if we are at blank child path
          component: CourseDetailComponent // we were loading this at courses/:id. now it's courses/:id/''
        },
        {
          path: 'new', //if we are at courses/url/new we are adding a new lesson to a course
          component: NewLessonComponent
        }
      ]
    },
    {
      path: '',
      component: CoursesComponent
    }
  ]
},

then in course-detail we can add:
<button routerLink="new">New Lesson</button>

new lesson component needs to know which course we're adding to. add this as an optional parameter.
we use query parameters to add it after 'new' so w get 'course/id/new?courseid'

here we actually want the course id. 

<button routerLink="new" [queryParams]="{courseId: (course$ | async)?.$key}">New Lesson</button>

we pass an object to queryParams directive
object creates courseId key that we store stuff in in the url.
Then since course is an observable, we pass it through the async pipe and the elvis operator to get the key out.

Now in the new lesson component, we need to get that url parameter back out:

import the ActivatedRoute and LessonsService and inject into constructor

then in ngOnInit we can extract it and assign it to a variable:

  courseId: string;

  ngOnInit() {
    this.courseId = this.route.snapshot.queryParams['courseId'];
    console.log("course", this.courseId);
  }

  At this point you can navigate to the new lesson component for a course and see the course id printed out.

  _______________
  38. Creating the Lesson Form Component - Used both for Edit and for Creation

inside of the new lesson component we add 
<lesson-form></lesson-form>
<button>Save New Lesson</button>

Then create form fields in lesson form component. 

This format, with a div with label, input, error message for each field.

<form [formGroup]="form" autocomplete="off" novalidate>
  <fieldset>
    <legend>Lesson</legend>
    <div class="form-field">
      <label>Description</label>
      <input name="title">
      <div class="field-error-message">Field is mandatory</div>
    </div>
  </fieldset>
</form>

now in lesson-form component half, import FormGroup, Validators and FormBuilder from '@angular/forms'.
inject FormBuilder. create property called 'form' of type FormGroup. 
the property "form" goes with [formGroup]="form" directive in form tag to bind the form html to the form property in the component half.

then we initialize the form. add these directives to each field input tag:
formControlName="description"
formControlName="url"
formControlName="videoUrl"
formControlName="tags"
formControlName="longDescription"

then matching in ngOnInit:

  ngOnInit() {
    this.form = this.fb.group({
      description: ['placeholder', Validators.required],
      url: ['', Validators.required],
      videoUrl: ['', Validators.required],
      tags: ['', Validators.required],
      longDescription: ['']
    });
  }

  I guess name="title" in each form input doesn't matter? they are all title in his case.

Then the error messages with validation:

  Then we add *ngIf="isErrorVisible('description', 'required')" to each div with an error message and declare the function in the component:


  isErrorVisible(field: string, error:string) {
    return this.form.controls[field].dirty //has been touched
      && this.form.controls[field].errors //if form is associated with the field
      && this.form.controls[field].errors[error]; //if the error includes the given error.
  }
______________

39. Lessons Service - Add Save New Lesson Functionality THIS VIDEO IS LATER AND TRADED WITH THE EDIT ONE.

in the new-lesson component we create a local variable 'form' and when we click the save button we trigger the save method and pass in the form.

<lesson-form #form></lesson-form>
<button (click)="save(form)">Save New Lesson</button>

Now we need the save method in the new-lesson component:


  save(form) {
    this.lessonsService.createNewLesson(this.courseId, form.value)
      .subscribe( //returns observable which we subscribe to.
        () => {
          alert('lesson saved');
          form.reset();
        },
        err => {
          alert('error:' + err);
        }
      );
  }

To make the form.reset method in our save method work, we need to add that reset method to the lesson-form component:


  reset() {
    this.form.reset();
  }

LESSONS SERVICE:


We need to talk directly to the root node of our database through the sdk to make sure that the lessons table and the lessonsPerCourse table are updated completely at the same time. we don't want inconsistencies in our generated ids. So, we create the reference called 'sdkDb' by injecting the firebase sdk directly.


sdkDb: any;

constructor(private af: AngularFire, @Inject(FirebaseRef) fb) { 
  this.sdkDb = fb.database().ref();
}

To make this work we also need to import a couple things. Here's the full list:

import { Injectable, Inject } from '@angular/core';
import { Observable } from 'rxjs/Rx';
import { Lesson } from './lesson';
import { AngularFire, FirebaseRef } from 'angularfire2';
import { Subject } from "rxjs/Rx";

Then we create the createNewLesson method in the lessonsService, and another method that it calls to update the database. We want the update database method separate so that we can use it for editing lessons.


  createNewLesson(courseId:string, lessonData:any):Observable<any> {
    // prepare data we want to save. create new object passing lesson data and courseId
    const lessonToSave = Object.assign({}, lessonData, { courseId: courseId });
    // create new id of lesson by saying:
    // hey sdk create a child in the lessons table
    // call push method without passing in the data yet to just create the slot. 
    // call '.key' to get the key property and store it.
    const newLessonKey = this.sdkDb.child('lessons').push().key;
    // then we want to save both into lessons and lessonsPerCourse at the same time to make sure they are consistent.
    // create empty object of data to save.
    let dataToSave = {};
    // add property with URL for each table. 
    dataToSave["lessons/" + newLessonKey] = lessonToSave;
    dataToSave["lessonsPerCourse/" + courseId + "/" + newLessonKey] = true;
    // save into both tables at once. we will need this to edit lessons too, so separate function.
    return this.firebaseUpdate(dataToSave);

  }

  firebaseUpdate(dataToSave) {
    // create rxjs subject so that we can convert it to an observable to return. we want to stay consistent and use observables rather than promises or callbacks. 
    const subject = new Subject();
    this.sdkDb.update(dataToSave)
      .then(
          val => {
            subject.next(val);
            subject.complete();
          },
          err => {
            subject.error(err);
            subject.complete();
          }
        );
    return subject.asObservable();
  }
}

Finally, in the new-lesson component we want to disable the save button if the form is not valid:

<lesson-form #form></lesson-form>
<button [disabled]="!form.valid" (click)="save(form)">Save New Lesson</button>

And we need to add that .valid method to the lesson-form component.


  get valid() {
    return this.form.valid;
  }

  Finally, to make that form.value method work we need to add this method to this method to lesson-form.component because when we are passing in #form to the save method in the new-lesson template, it is the lesson-form component itself not the form. The form is a property on that component. So we declare the get value method in the lesson-form component.


  get value() {
    return this.form.value;
  }

___________________________

40.  Add New Lesson - Add a Custom Url Field Validator

Create file validateUrl.ts in shared/validators. 

after exporting validator function, include it in the list of validators in lesson-form.component

instead of this:

videoUrl: ['', Validators.required],

We want:

videoUrl: ['', [Validators.required, validateUrl]],

you can include an array of as many validator functions as you need. don't forget to import them in that same component.

import { validateUrl } from '../shared/validators/validateUrl';

then we can check for the error in the url field the same way as we did with the 'required' errors:

<div *ngIf="isErrorVisible('videoUrl', 'validUrl')" class="field-error-message">Not a valid url</div>

we pass in the string for the field we're validating and the name of the property in our object returned from validateUrl function to the lesson form 'isErrorVisible' method.

______________
41.  Edit Lesson - Initial Screen Setup

we want to click the edit button to open the same form as the one for saving a new lesson, but instead we want to pass in the properties of the current lesson so we can edit them and resave it. 

ng g component edit-lesson

then create button with routerLink. We want this button to show up on the lesson-details component.

<button routerLink="edit">Edit Lesson</button>

Then we add to the router configuration. Instead of:


  {
    path: 'lessons/:id',
    component: LessonDetailComponent
  },

  We want this:


  {
    path: 'lessons/:id',
    children: [
      {
        path: '',
        component: LessonDetailComponent
      },
      {
        path: 'edit',
        component: EditLessonComponent
      }
    ]
  },

Also, import the new component:

import {EditLessonComponent} from './edit-lesson/edit-lesson.component';

At this point you should be able to click the edit button to navigate to the new component.

Then in the edit lesson component template we want to load the lesson form and add a save button. we want to pass into the lesson form the initial values of the current lesson. We'll create a property called 'initialValue' inside of the lesson-form component.

<lesson-form [initialValue]="lesson"></lesson-form>
<button>Save Changes</button>

Then in the lesson-form.component.ts file we need to add:

import { Component, OnInit, Input } from '@angular/core';


@Input()
  initialValue: any;

_____________

42. Edit Lesson - Retrieve Lesson using the Router Resolve Functionality

Angular 2 router resolve functionality. how to write resolvers.
writing a data resolver with observables
for trying to do a transition between routes.

then in edit lesson component.ts:

import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { Lesson } from '../shared/model/lesson';


@Component({
  selector: 'app-edit-lesson',
  templateUrl: './edit-lesson.component.html',
  styleUrls: ['./edit-lesson.component.css']
})
export class EditLessonComponent implements OnInit {

  lesson: Lesson;

  constructor(private route: ActivatedRoute) {  
    //receives input data for the component before component was created by router.
    route.data.subscribe(
      data => this.lesson = data['lesson']
    )
  }

  ngOnInit() {
  }

}

Then connect it up in the router:


  {
    path: 'lessons/:id',
    children: [
      {
        path: '',
        component: LessonDetailComponent
      },
      {
        path: 'edit',
        component: EditLessonComponent,
        resolve: {
          lesson: LessonResolver
        }
      }
    ]
  },

This way we can pass in a whole lesson object without a url.
Finally we need to declare LessonResolver. create shared/model/lesson.resolver.ts:

import { Resolve, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { Lesson } from './lesson';
import { Observable } from 'rxjs/Rx';
import { Injectable } from '@angular/core';
import { LessonsService } from './lessons.service';


@Injectable()
export class LessonResolver implements Resolve<Lesson>{

  constructor(private lessonsService: LessonsService) {

  }

  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot):Observable<any>{
    return this.lessonsService.findLessonByUrl(route.params['id']);
  }
}


And we add it to the providers array and import it in the app.module file.

import { LessonResolver } from './shared/model/lesson.resolver';

  providers: [LessonsService, CoursesService, LessonResolver],

And we import it into the router.config file too:

import { LessonResolver } from './shared/model/lesson.resolver';


at this point if we hit the edit button nothing happens. no errors no transition to new component. wtf? common problem with observables apparently. have to make sure the observable completes so call 'first' on it in lesson.resolver.ts.

return this.lessonsService.findLessonByUrl(route.params['id']).first();

if we click edit we still can't see anything in the form, but we are navigated correctly to the form.

________________
43. Edit Lesson - Passing the Retrieved Data to the Lesson Form

In LESSON FORM COMPONENT.

Finally, we have to pass that initial value into the form inside of the lesson-form component to deal with the edit case.

1. import OnChanges and SimpleChanges:

2. then add implements ngOnChanges to class declaration, and add  ngOnChanges method. it will look for any time a new value is passed in for a lesson to edit.

3. Move the ngOnInit stuff to the constructor because we have to make sure we initialize the form before looking for changes in the initial value. Can't load the lesson into the form if the form doesn't exist yet.

import { Component, OnInit, Input, OnChanges, SimpleChanges } from '@angular/core';
import { FormGroup, FormBuilder, Validators } from '@angular/forms';
import { validateUrl } from '../shared/validators/validateUrl';


@Component({
  selector: 'lesson-form',
  templateUrl: './lesson-form.component.html',
  styleUrls: ['./lesson-form.component.css']
})
export class LessonFormComponent implements OnInit, OnChanges {

  form: FormGroup;
  @Input()
  initialValue: any;

  constructor(private fb: FormBuilder) { 
    // initialize form from constructor so that afterwards we can detect changes in initial value and display lesson values in edit form.
    this.form = this.fb.group({
      description: ['placeholder', Validators.required],
      url: ['', Validators.required],
      videoUrl: ['', [Validators.required, validateUrl]],
      tags: ['', Validators.required],
      longDescription: ['']
    });

  }

  ngOnChanges(changes:SimpleChanges) {
    //make sure form is initialized and look for changes to initialValue input property
    if(this.form && changes['initialValue']) {
      this.form.patchValue(changes['initialValue'].currentValue)
    }
  }

Hooray! Now we should be able to hit edit and see the lesson-form component with values from the current lesson.
__________________________

44. Lessons Service - Add Save New Lesson Functionality

Now we need to be able to send the form values to the database through the lessons service to update the lesson we're editing. Let's connect the form lesson-form component to the edit-lesson component that's loading it. in edit-lesson.html

<lesson-form [initialValue]="lesson" #form></lesson-form>
<button (click)="save(form.value)">Save Changes</button>

Then in edit-lesson.component.ts we import and inject the lessons service:

import { LessonsService } from "../shared/model/lessons.service";
  constructor(private route: ActivatedRoute,  private lessonsService:LessonsService) {  

  and declare save method:

  save(lessonData) {
  // sends lesson key and data from form to service
    this.lessonsService.saveEditedLesson(this.lesson.$key, lessonData)
      .subscribe(
        () => {
          alert('edited lesson saved');
        },
        err => {
          alert('error saving lesson: ' + err);
        }
      )
  }

then declare the saveEditedLesson method in the service that we call above:
  save(lessonData) {
    // added these two lines in myself because these properties are not in our form so they get lost on save.
    lessonData['courseId'] = this.lesson.courseId;
    lessonData['duration'] = this.lesson.duration;
    this.lessonsService.saveEditedLesson(this.lesson.$key, lessonData)
      .subscribe(
        () => {
          alert('edited lesson saved');
        },
        err => {
          alert('error saving lesson: ' + err);
        }
      )
  }

  _________________

45.  Setup Firebase Authentication, Create a Login Page

ng g component login
ng g component register

then in router:

{
  path: 'login',
  component: LoginComponent
},
{
  path: 'register',
  component: RegisterComponent
}

then add links in top-menu

<a routerLink="login">Login</a>
<a routerLink="register">Register</a>
<a>Logout</a>

Only want to show login and register if not logged in, and only show logout if you are logged in.

ng g service shared/security/auth

add service to app.module providers

then login component.html

<form novalidate [formGroup]="form">

  <fieldset>
    <legend>Login</legend>
    <div class="form-field">
      <label>Email:</label>
      <input name="email" formControlName="email">
    </div>
     <div class="form-field">
      <label>Password:</label>
      <input name="password" formControlName="password" type="password">
    </div>
  </fieldset>

  <button (click)="login()">Login</button>
</form>

then login component.ts:

add form property, inject formbuilder in constructor and init with validators

  form: FormGroup;

  constructor(private fb:FormBuilder, private authService:AuthService,
    private router:Router) { 
    this.form = this.fb.group({
      email: ['', Validators.required],
      password: ['', Validators.required],
    });
  }

Then in firebase main menu > auth > set up signin email/password
add an admin user to test in interface
inject and import the auth service and Router in login component
declare login method to go with button

also import and inject auth service then make login function

import { FormGroup, FormBuilder, Validators } from '@angular/forms';
import {AuthService} from "../shared/security/auth.service";
import {Router } from '@angular/router';


  login(){
    //get form values, pass to login method in auth service we're about to make
    const formValue = this.form.value;
    this.authService.login(formValue.email, formValue.password)
      .subscribe( //navigate home on successful login, if error, call alert.
        ()=>this.router.navigate(['/home']),
        alert
      );
  }


in auth service:

import { Injectable } from '@angular/core';
import { AngularFireAuth } from 'angularfire2/index';
import { Observable, Subject } from 'rxjs/Rx';

@Injectable()
export class AuthService {

  constructor(private auth: AngularFireAuth) { }

  login(email, password):Observable<any>{
    // call the login method on angularfire's firebaseauth module, returns promise, convert to observable.
    return this.fromFirebaseAuthPromise(this.auth.login({ email: email, password: password }));
  }

  //method to convert a promise into an observable to return above.
  fromFirebaseAuthPromise(promise):Observable<any> {
    const subject = new Subject<any>();
    promise.then(
      res => {
        subject.next(res);
        subject.complete();
      },
      err => {
        subject.error(err);
        subject.complete();
      }
    );
    return subject.asObservable();
  }
}


Then we have to specify which login methods are available in our environments/firebase.config.ts file. this grabs what we have turned on in the firebase console.

import { AuthMethods, AuthProviders } from 'angularfire2/index';

export const firebaseConfig = {
  apiKey: "AIzaSyAwuKl7qjXwEFV4e_XdCLY8goNChIMgc1w",
  authDomain: "tutorial-b967f.firebaseapp.com",
  databaseURL: "https://tutorial-b967f.firebaseio.com",
  storageBucket: "tutorial-b967f.appspot.com",
  messagingSenderId: "979501840072"
};

export const authConfig = {
  provider: AuthProviders.Password,
  method: AuthMethods.Password
}

then pass it in app.module:

import { authConfig } from "../environments/firebase.config";
AngularFireModule.initializeApp(firebaseConfig, authConfig),
  ____________________

  46. Building an Authentication Observable Data Service

we need to hide things based on whether or not someone is logged in.
create shared/model/auth-info.ts

export class AuthInfo {
  
  constructor(public $uid:string) {

  }

  isLoggedIn() {
    return !!this.$uid;
  }
}

then we set it up in the auth service:

by importing authinfo class with method to tell is logged in, as well as something called a behavior subject which will tell the whole rest of the app if the user is currently logged in or not. Then we create the authInfo$ property which is what other parts of the app subscribe to to know if logged in user or not. observable of type auth info. then we emit the new instance of auth info when the user logs in, and the error if they fail at logging in. do it from the 'fromFirebaseAuthPromise' method.

import { Injectable } from '@angular/core';
import { AngularFireAuth } from 'angularfire2/index';
import { Observable, Subject, BehaviorSubject } from 'rxjs/Rx';
import { AuthInfo } from '../model/auth-info';

@Injectable()
export class AuthService {

  // a behavior subject is guaranteed to give you a value when you subscribe
  // create a default anonymous user to pass into our Behavior Subject of type AuthInfo
  // this behavior subject makes auth state available to the whole app without having to subscribe to the login method
  static UNKNOWN_USER = new AuthInfo(null);
  public authInfo$: BehaviorSubject<AuthInfo> = new BehaviorSubject<AuthInfo>(AuthService.UNKNOWN_USER);


  constructor(private auth: AngularFireAuth) { }

  login(email, password):Observable<any>{
    // call the login method on angularfire's firebaseauth module, returns promise, convert to observable.
    return this.fromFirebaseAuthPromise(this.auth.login({ email: email, password: password }));
  }

  //method to convert a promise into an observable to return above.
  fromFirebaseAuthPromise(promise):Observable<any> {
    const subject = new Subject<any>();
    promise.then(
      res => {
        // when logging in, create auth info instance and pass in uid generated by firebase of newly logged in user.
        const authInfo = new AuthInfo(this.auth.getAuth().uid);
        // then emit new value from AuthInfo observable by calling next.
        this.authInfo$.next(authInfo);
        subject.next(res);
        subject.complete();
      },
      err => {
        // also call error if there is a problem passing in the error info.
        this.authInfo$.error(err);
        subject.error(err);
        subject.complete();
      }
    );
    return subject.asObservable();
  }
}

Now, we can use this in the top-menu component:
import authservice, authinfo class. 
inject service with the observable authinfo property on it that we just made.
then subscribe to it in ngOnInit.

import { Component, OnInit } from '@angular/core';
import { AuthService } from '../shared/security/auth.service';
import { AuthInfo } from '../shared/model/auth-info';

@Component({
  selector: 'top-menu',
  templateUrl: './top-menu.component.html',
  styleUrls: ['./top-menu.component.css']
})
export class TopMenuComponent implements OnInit {

  authInfo: AuthInfo;

  constructor(private authService: AuthService) { }

  ngOnInit() {
    this.authService.authInfo$.subscribe(authInfo => this.authInfo = authInfo);
  }

}

Finally, we can use this observable property in the template to only show the login links if the user is not logged in yet, and only show logout if they are logged in.

  <a routerLink="login" *ngIf="!authInfo?.isLoggedIn()">Login</a>
  <a routerLink="register" *ngIf="!authInfo?.isLoggedIn()">Register</a>
  <a *ngIf="authInfo?.isLoggedIn()">Logout</a>

Just a note: 
https://angular-university.io/lesson/angular2-firebase-authentication-observable-data-service

I'm getting this warning:

WARNING: the getAuth() API has changed behavior since adding support for Firebase 3.
This will return null for the initial value when the page loads, even if the user is actually logged in.
Please observe the actual authState asynchronously by subscribing to the auth service: af.auth.subscribe().
The getAuth method will be removed in future releases

Someone did refactor but I haven't tried this yet. in the auth service:

constructor(public auth: FirebaseAuth,
                public af: AngularFire) {

        this.af.auth.subscribe(auth => {
            if (auth) {
                const authInfo = new AuthInfo(auth.uid);
                this.authInfo$.next(authInfo);
            }
            else {
                this.authInfo$.next(AuthService.UNKNOWN_USER);
            }
        });
    }

    https://disq.us/url?url=https%3A%2F%2Fgist.github.com%2Fkimonio%2Fba1846c6c243f3aeaead3c38ca6df7b5%3AtHozDhlm9ZMAm0lX5bBpQHDyoR4&cuid=4188724

It's working for now, try this later.
  __________________

47. Build a User Registration Page

First we need a form. Almost the same as login form. disable button if passwords don't match, and apparently there are some builtin rules to firebase password auth because mine had to be at least 6 characters long.

register.component.html

  <form novalidate [formGroup]="form">

  <fieldset>
    <legend>Register</legend>
    <div class="form-field">
      <label>Email:</label>
      <input name="email" formControlName="email">
    </div>
     <div class="form-field">
      <label>Password:</label>
      <input name="password" formControlName="password" type="password">
    </div>
     <div class="form-field">
      <label>Confirm Password:</label>
      <input name="confirm" formControlName="confirm" type="password">
    </div>
  </fieldset>
  <!-- disable register button if passwords do not match -->
  <button (click)="register()" [disabled]="!isPasswordMatch()">Register</button>
</form>

then we initialize the form, add the register method and the isPasswordMatch method to the register.component.ts file (no need for ngOnInit):

import { Component, OnInit } from '@angular/core';
import { FormGroup, FormBuilder, Validators } from '@angular/forms';
import {AuthService} from "../shared/security/auth.service";
import {Router } from '@angular/router';


@Component({
  selector: 'app-register',
  templateUrl: './register.component.html',
  styleUrls: ['./register.component.css']
})
export class RegisterComponent {

  form: FormGroup;

  constructor(private fb: FormBuilder, 
              private authService: AuthService,
              private router: Router) { 

    this.form = this.fb.group({
      email: ['', Validators.required],
      password: ['', Validators.required],
      confirm: ['', Validators.required]
    });

  }

  isPasswordMatch() {
    const formData = this.form.value;
    // return true only if the form data and the password field are not blank
    // and if the password field is equal to the confirm field  
    return formData && formData.password && formData.password == formData.confirm; 
  }

  register() {
    const formData = this.form.value;
    this.authService.signUp(formData.email, formData.password)
      .subscribe(
        () => {
          alert('user created!'); //confirm message and then to /home.
          this.router.navigateByUrl('/home');
        },
        err => alert(err) //otherwise show error.
      );
  }

}

Then we add the signup method to the auth service. Exactly the same as the login method except that we call the angularfire 'createUser' method instead of 'login' method:

  signUp(email, password):Observable<any>{
    // call the createUser method on angularfire's firebaseauth module, returns promise, convert to observable.
    return this.fromFirebaseAuthPromise(this.auth.createUser({ email: email, password: password }));
  }

  _________________________

  48. Setup the Logout Functionality

  First add a click handler to call a logout method in the top-menu component from logout link:

  <a (click)="logout()" *ngIf="authInfo?.isLoggedIn()">Logout</a>

  Then implement that method in the component to simply call the auth service method of same name. Keep all the auth stuff together in service so that components are transparent and don't need to know about angularfire.

    // keep this separate from this particular component by putting logout in service.
  logout() {
    this.authService.logout();
  }


  Then in the auth service:

    logout() {
    this.auth.logout();
    //emit a new value to all components that user is no longer authenticated.
    this.authInfo$.next(AuthService.UNKNOWN_USER);
  }

  _____________

49. Redirect User To Login Page Using a Router Guard

  We should only be able to see a lesson if we're logged in. 
  In security folder create auth.guard.ts
It's just a class but it's going to implement an interface called "CanActivate"

import {CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router} from '@angular/router';
import {Observable} from 'rxjs/Rx';
import {Injectable} from '@angular/core';
import {AuthService} from'./auth.service';


@Injectable()
export class AuthGuard implements CanActivate {
  
  constructor(private authService:AuthService, private router:Router ) {
  }

  canActivate(route:ActivatedRouteSnapshot,
              state:RouterStateSnapshot):Observable<boolean> {
    // authservice gives us authinfo$ observable. 
    // this gives as value an object of authInfo which has bool isLoggedIn
    // take(1) is a way of making the observable 'complete' like a promise.
    return this.authService.authInfo$
        .map(authInfo => authInfo.isLoggedIn())
        .take(1)
        .do(allowed => {
            //if not allowed, redirect to login.
            if(!allowed) {
                this.router.navigate(['/login']);
            }
        });
  }
}

then add AuthGuard to providers array in app.module:

import {AuthGuard} from "./shared/security/auth.guard";

providers: [LessonsService, CoursesService, LessonResolver, AuthService, AuthGuard],

Then, you can use it by adding a property to any of your router config objects to protect it from unauthenticated users and redirect them to login:

first import again:
import {AuthGuard} from'./shared/security/auth.guard';

then this lets you only be able to view lessons if you are logged in. 
  {
    path: 'lessons/:id',
    children: [
      {
        path: '',
        component: LessonDetailComponent,
        canActivate: [AuthGuard]
      },
      {
        path: 'edit',
        component: EditLessonComponent,
        canActivate: [AuthGuard],
        resolve: {
          lesson: LessonResolver
        },
      }
    ]
  }

_________________________________

50. REST and Firebase - Using the Firebase REST API

we can also talk to the database with its built in rest api. responds to get, patch, put, delete 

We will use this for delete.

import HttpModule to app.module and include it in the imports array:
  
  import { HttpModule } from '@angular/http';

  imports: [
    BrowserModule,
    AngularFireModule.initializeApp(firebaseConfig, authConfig),
    FormsModule,
    HttpModule,
    ReactiveFormsModule,
    RouterModule.forRoot(routerConfig)
  ],

add click handler to delete method on delete button in the lesson detail component.

  <button (click)="delete()">Delete Lesson</button>

  delete() {
    this.lessonsService.deleteLesson(this.currentLesson.$key);
  }

then implement in service:

import { Http } from '@angular/http';
import { firebaseConfig } from "../../../environments/firebase.config";


constructor(private af: AngularFire, @Inject(FirebaseRef) fb, private http:Http) { 
  this.sdkDb = fb.database().ref();
}

  deleteLesson(lessonId:string):Observable<any> {
    const url = firebaseConfig.databaseURL + '/lessons/' + lessonId + '.json';
    return this.http.delete(url);
  }

  Works, and is pretty good, but doesn't delete the relationship in lessonsPerCourse.

  So I added a second method called from the delete button!

  from the lesson detail component html:

  <button (click)="delete(); deleteLessonPerCourse();">Delete Lesson</button>

  triggers the lesson detail component.ts:


  delete() {
    this.lessonsService.deleteLesson(this.currentLesson.$key)
      .subscribe(
          () => {
            alert('yo i am deleted son!');
          },
          console.error
        );
  }
  deleteLessonPerCourse() {
    this.lessonsService.deleteLessonPerCourse(this.currentLesson.$key, this.currentLesson.courseId)
      .subscribe(
          () => {
            alert('yo i am deleted son!');
            this.router.navigate(['/home']);
          },
          console.error
        );
  }

  which triggers both methods in the service. WOOOO!

  deleteLesson(lessonId: string):Observable<any> {
    const url = firebaseConfig.databaseURL + '/lessons/' + lessonId + '.json';
    return this.http.delete(url);
  }

  deleteLessonPerCourse(lessonId: string, courseId:string):Observable<any> {
    const urlLessonsPerCourse = firebaseConfig.databaseURL + '/lessonsPerCourse/' + courseId + '/' + lessonId + '.json';
    return this.http.delete(urlLessonsPerCourse);
  }